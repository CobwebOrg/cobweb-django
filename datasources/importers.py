import inspect, reversion
from sys import stderr, stdout

# from django.conf import settings
# from django.contrib.auth import get_user_model
# from django.db import models
from sickle import Sickle

from archives.models import Collection, Holding
from core.models import Organization
from metadata.models import MDVocabulary, MDProperty, Metadatum
from webresources.models import nocrypto_url

# circular import that shouldn't work right
# just want to see if a linter or whatever catches it
import datasources.models 


def eprint(*args, **kwargs):
    print(*args, file=stderr, **kwargs)

# def get_organization(record):
#     if (len(record.header.setSpecs) == 1 
#             and record.header.setSpecs[0][:13] == 'organization:'):
#         id_number = record.header.setSpecs[0][13:] # actually should be string
#         org_url, api_url = setspec_to_urls(only_one(setspec))
#         return uri, api_url
#     else:
#         eprint(record.header.identifier, record.header.setSpecs)
#         raise ValueError("Can't find organization from setspecs.")

def only_one(list_object):
    """If list_object has only 1 item, return it. Otherwise raise ValueError"""
    if len(list_object) == 1:
        return list_object[0]
    else:
        eprint(list_object)
        raise ValueError("Expected a list with exactly one item")

class Importer:
    IS_IMPORTER = True

    def harvest(self):
        """Does nothing but save any queued unsaved objects. Subclasses should
        override this function to do harvest data, adding any unsaved objects
        to the set self.unsaved, then call super().harvest() to save them."""
        with reversion.create_revision():
            reversion.set_user(self.api.get_agent())
            for unsaved_object in self.__harvest_all__():
                print("Saving {}".format(unsaved_object))
                try:
                    unsaved_object.fill_fields_from_metadata()
                except AttributeError:
                    # Funciton not defined - don't worry, it's optional!
                    pass
                unsaved_object.full_clean()
                unsaved_object.save()

class OAIPMHImporter(Importer):

    set_class = Collection
    record_class = Holding

    def __init__(self, api):
        self.api = api
        self.sickle = Sickle(self.api.location)

    def __harvest_all__(self):
        unsaved = set( self.__harvest_api_identification__() )

        for setspec in self.sickle.ListSets():
            unsaved.update( self.__harvest_setspec__(setspec) )

        for record in self.sickle.ListRecords(metadataPrefix='oai_dc'):
            unsaved.update( self.__harvest_record__(record) )

        return unsaved

    def __harvest_record__(self, record):
        uri2 = record.metadata.pop('identifier')
        uri = nocrypto_url( record.header.identifier )

        print(uri)
        stdout.flush()

        set_uri = self.__get_set_identifier__(only_one(record.header.setSpecs))

        if self.set_class is Organization:
            set_key = 'organization'
        elif self.set_class is Collection:
            set_key = 'collection'
        target = self.record_class.objects.get_or_create(
            identifier=uri,
            defaults={
                'name': "Autogenerated {} for {}"
                    .format(self.record_class, uri),
                set_key: self.set_class.objects.get_or_create(
                    identifier=set_uri,
                    defaults={
                        'name': "Autogenerated {} for {}"
                        .format(self.set_class, set_uri)
                    }
                )[0]
            }
        )[0]

        target.raw_metadata = record.raw

        try:
            target.name = ' / '.join( record.metadata['title'] )
        except Exception as ex:
            eprint(ex, type(ex))

        try:
            target.description = only_one(record.metadata.pop('description'))
        except Exception as ex:
            eprint(ex, type(ex))

        self.__attach_metadata__(target, record.metadata, 'oai_dc')

        return {target}

    def __get_set_identifier__(setspec):
        return setspec

    def __harvest_api_identification__(self):
        unsaved = set()
        metadata = dict(self.sickle.Identify())

        assert ( nocrypto_url( only_one( metadata.pop('baseURL') )) 
            == nocrypto_url(self.api.location) )

        if self.api.organization:
            self.api.organization.name = only_one(metadata['repositoryName'])
            unsaved.add(self.api.organization)

        self.__attach_metadata__(self.api, metadata, 'DC?')
        return unsaved.union({ self.api })

    def __harvest_setspec__(self, source):
        if (source.setSpec == 'organization' 
                and source.setName == 'organization'):
            # archive-it is feeding us a dummy record
            return set()
        try:
            uri = self.__get_set_identifier__(source.setSpec)
            target = self.set_class.objects.get_or_create(identifier=uri)[0]
            target.name = source.setName
            return {target}
        except Exception as ex:
            eprint(ex, type(ex))
            return set()


    def __attach_metadata__(self, target, metadata, vocabulary_name):
        vocab = MDVocabulary.objects.get_or_create(name=vocabulary_name)[0]
        for key, values in metadata.items():
            md_property = MDProperty.objects.get_or_create(
                vocabulary=vocab, name=key)[0]
            for value in values:
                target.metadata.add(
                    Metadatum.objects.get_or_create(
                        md_property=md_property, name=value)[0]
                )


class AITCollectionsImporter(OAIPMHImporter):
    set_class = Organization
    record_class = Collection


    def __harvest_record__(self, record):
        unsaved = super().__harvest_record__(record)

        for target in unsaved:
            if type(target) is Organization:
                for setspec in record.header.setSpecs:
                    target.metadata.add(
                        Metadatum.objects.get_or_create(
                            md_property = MDProperty.objects.get_or_create(
                                vocabulary = MDVocabulary.objects.get_or_create(
                                    name="<APIEndpoint>"),
                                md_property = "location"
                            ),
                            name = self.__get_set_api__(setspec)
                        )
                    )

        return unsaved

    def __get_set_identifier__(self, setspec):
        try:
            set_type, set_number = setspec.split(':')
            return "http://archive-it.org/organizations/{}".format(
                set_type, set_number)
        except Exception as ex:
            eprint(ex, type(ex))

    def __get_set_api__(self, setspec):
        try:
            set_type, set_number = setspec.split(':')
            if set_type is 'organization':
                return ( "https://archive-it.org/oai/organizations/{}"
                    .format(set_id) )
            else:
                return None
        except Exception as ex:
            eprint(ex, type(ex))

importers = { name: thing for name, thing in globals().items()
              if inspect.isclass(thing) and issubclass(thing, Importer) }