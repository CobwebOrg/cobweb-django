from django.core.management.base import BaseCommand, CommandError
from math import inf
from sickle import Sickle
from sys import stderr

from archives.models import Collection
from core.models import Organization, User
from datasources.models import APIEndpoint
from webresources.models import nocrypto_url


AIT_COLLECTIONS_API = "https://archive-it.org/oai"
USER = User.objects.get_or_create(username="admin")[0]

# def ait_partner_records(organization_id):
#     return "https://archive-it.org/oai/organizations/{:04d}".format(organization_id)

def eprint(*args, **kwargs):
    print(*args, file=stderr, **kwargs)

def setspec_to_urls(setspec):
    if setspec[:13] == 'organization:':
        org_id = setspec[13:]
        org_url = "http://archive-it.org/organizations/{}".format(org_id)
        api_url = "https://archive-it.org/oai/organizations/{}".format(org_id)
        return org_url, api_url
    else:
        raise ValueError("Can't find parse setSpec: {}".format(setspec))

def get_organization(record):
    if len(record.header.setSpecs) == 1 and record.header.setSpecs[0][:13] == 'organization:':
        id_number = record.header.setSpecs[0][13:] # actually should be string
        org_url, api_url = setspec_to_urls(only_one(setspec))
        return uri, api_url
    else:
        eprint(record.header.identifier, record.header.setSpecs)
        raise ValueError("Can't find organization from setspecs.")

def only_one(list_object):
    """If list_object has exactly 1 item, returns it. Otherwise raises ValueError"""
    if len(list_object) == 1:
        return list_object[0]
    else:
        raise ValueError("Expected a list with exactly one item")

# def get_ait_collection_id(record):
#     if record.header.identifier[:34] ==  'http://archive-it.org/collections/':
#         return int(record.header.identifier[34:])
#     else:
#         eprint(record.header.identifier)
#         raise ValueError("Can't parse collection number.")

# def collection_id_range(records):
#     oids = [ get_ait_collection_id(record) for record in records ]
#     if len(oids) > 1:
#         return (min(oids), max(oids))
#     else:   
#         eprint(oids)
#         raise ValueError("Can't get collection id number range.")

        

class Command(BaseCommand):
    help = 'Crudely imports some data about Archive-It collections'

    def harvest_record(self, record):
        uri2 = record.metadata.pop('identifier')
        uri = nocrypto_url( record.header.identifier )

        organization_uri, organization_api = setspec_to_urls(only_one(record.header.setSpecs))
        collection = Collection.objects.get_or_create(
            identifier=uri,
            defaults={
                'name': "Autogenerated Collection for {}".format(uri),
                'organization': Organization.objects.get_or_create(
                    identifier=organization_uri,
                    defaults={
                        'name': "Autogenerated Organization for {}".format(organization_uri)
                    }
                )[0]
            }
        )[0]


        APIEndpoint.objects.get_or_create(
            organization = collection.organization,
            location = organization_api,
            protocol = PROTOCOL,
        )

        collection.raw_metadata = record.raw

        try:
            collection.name = ' / '.join( record.metadata.pop('title') )
        except Exception as ex:
            eprint(ex, type(ex))

        # try:
        #     collection.description = only_one(record.metadata.pop('description'))
        # except Exception as ex:
        #     eprint(ex, type(ex), record.metadata.keys())

        # for tag_property, tag_values in record.metadata.items():
        #     for tag_value in tag_values:
        #         try:
        #             collection.tags.add(
        #                 Tag.objects.get_or_create(
        #                     tag_property=tag_property,
        #                     tag_value=tag_value
        #                 )[0]
        #             )
        #         except Exception as ex:
        #             eprint(ex, type(ex))

        collection.full_clean()
        collection.save()

    def harvest_identification(self, sickle):
        identification = sickle.Identify()
        organization = Organization.objects.get_or_create(identifier = 'http://archive-it.org')[0]

        metadata = dict(identification)

        if not nocrypto_url(only_one(metadata.pop('baseURL'))) == nocrypto_url(AIT_COLLECTIONS_API):
            raise ValueError

        organization.name = only_one(metadata.pop('repositoryName'))

        # METADATA TAGS TO POSSIBLY HARVEST:
            # deletedRecord
            # earliestDatestamp
            # protocolVersion
            # adminEmail
            # granularity
        # also identification.raw

    def harvest_organization(self, org):
        if org.setSpec == 'organization' and org.setName == 'organization':
            # archive-it is feeding us a dummy record
            return
        try:
            organization_uri, organization_api = setspec_to_urls(org.setSpec)
            organization = Organization.objects.get_or_create(identifier=organization_uri)[0]
            organization.name = org.setName
            organization.save()
        except Exception as ex:
            eprint(ex, type(ex))

    def handle(self, *args, **kwargs):
        ait = Sickle(AIT_COLLECTIONS_API)

        self.harvest_identification(ait)

        for organization in ait.ListSets():
            self.harvest_organization(organization)

        records = ait.ListRecords(metadataPrefix='oai_dc')
        for record in records:
            self.harvest_record(record)